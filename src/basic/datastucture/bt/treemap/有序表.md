# 有序表
- 有序表是接口名 AVL树、 SB树和红黑树皆可实现有序表  可认为三者性能只在常数上有差别而没有时间复杂度的差别 O(lgN)
  - 实现方式（三种方式的受影响节点以及从受影响节点开始往上找父亲来查询删除等的路径是一样  只是各自做的动作不一样）
    - AVL树：严格左右节点高度差小于2
      - AVL树破坏平衡违规检查的方式  如何知道是LL LR RL RR的哪一种呢
      - 因为每次插入删除都会做检查，所以一定是在高度差为2的时候被找出来 那么此时高的那一侧一定只有一个孩子是高度减一
      - 否则会在之前的步骤中被检查出来 因此可以通过这个孩子在高的那一侧（左侧或右侧）的节点的左边或右边而找出是哪一种
      - 确定是哪一种就好办了  (四种调整每个都是O(1) -- 所以从受影响的节点往上找 O(lgN) )
        - LL 是左边子树的左边孩子造成过长  因此对头节点做个右旋 压他一头 左边提上来一次 就平了 
        - RR 和LL同理 只要对头节点做个左旋
        - LR或者是RL型的  想方设法让查到的这个破坏平衡的孙节点上到顶部来
    - SB树：叔节点的节点数不少于其侄子节点的节点数  （差距不会到2倍+1以上）  基本也是logN水平
    - 红黑树：
      - 定义有关
        - 头节点和叶子节点都是黑色
        - 红色节点一定生出黑节点  --> 不会有两个红色节点相邻 --> 最长的链应该是黑红交替
        - 节点到叶子节点各个路径黑节点一样多    --> 最长链(黑红交替)不可能超过最短链(全黑)两倍往上  保证基本是logN水平
