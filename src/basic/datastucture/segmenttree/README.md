# 线段树
## 线段树是一种支持区间范围整体修改或查询的数据结构 --> 区间修改树

## 基本要求：给定数据arr，在O(lgN)内实现三个方法

- void add(int L, int R, int V, arr)  --> arr[L..R]每个数加上V
- void update(int L, int R, int V, arr)  -->  arr[L..R]每个数变成V
- int sum(int L, int R)  --> 返回arr[L..R]累加和

## 线段树解决的问题范畴及注意点：
- 大范围信息可以由左右两侧信息直接汇总加工出来，而不必遍历左右两个子范围的具体状况（最大值、最小值、累加和等）
  - 补充成满二叉树  不想让二分的时候范围不对齐
    - 因此 最不省空间的时候就是数组长度相当于满二叉树多一个(比如5，9) 这时候要再补充成一个更大的满二叉树
    - 注意到此时要在N的基础上补充一个N级别的数量，叶子节点2N水平，那么整棵树的节点接近4N水平
    - 因此开辟4N空间做线段树就是考虑到了最不省空间的情况 一定够用
  - 下标从1开始  0位置弃而不用
    - 这样做可以用位运算代替2*i+1  -->   位运算写成(i<<1)|1) 这样能够方便省掉考虑0位置 对应左孩子是2*i+1 右孩子2*i+2(位运算不方便)的情况 
  - void add采用懒更新机制 当收到任务包含了当前位置所囊括的区间 存储在lazy信息中 不再下发到子区间 
    - 懒更新机制才能做到O(lgN)水平下发 如果每个节点都收到就是O(N)
    - 但注意 如果又来了新的任务需要执行，那么当前放的lazy信息就要继续下发一层给左右孩子 自己去执行新的信息任务
  - 自己敲代码时发现：
    - pushDown方法传入的ln和rn的范围+1的目的是把左右孩子自己算进去再包括它们的子孙
    - L <= mid  R >= mid同时写在代码中了 导致outOfRange 要细心 行百里这半九十