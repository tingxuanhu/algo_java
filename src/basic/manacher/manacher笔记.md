# manacher

- 暴力方法  从i位置往左右两边扩   只选字符扩充的话  长度为偶数的字符串是从两字符中间的虚轴扩出去的  可能找不到
--》 引入虚轴 # 标记

- Manacher的改进
- 用pArr数组在从左往右遍历过程中把以i位置为中心的结果记录下来  类似于动规 可以查到之前的结果
- 以i为中心能扩到最远的右边再加1（违规位置）定义为R 
- R更新为更大值的时候 更新当时的回文中心点C 记录下来
- 分类讨论：
1）当i遍历到R外的时候 没有优化 暴力向外扩充
<br/>
2）当i遍历在R内时  必然存在拓扑关系为： [L .. C .. i .. R] <br/>
因为i刚到的位置如果在R内 证明R一定是之前更新的 <br/>
因此C必然在i的左侧而不可能到右侧去 此时可以找i关于C的对称点i'  [L .. i' .. C .. i .. R]
- i关于C对称点i'的回文区域均落在L..R范围内  找i'回文区外围紧挨着的x和t 以及i回文区外紧挨着的y和z
  - 此时的拓扑结构为[L .. x(.. i' ..)t .. C .. y(.. i ..)z .. R]
  - 此前遍历到i'时把答案记在了pArr中
  - 因为i与i'关于C对称  i的回文区域应当至少是i'的回文范围
  - 假定还能往外扩 那么y==z   根据关于C对称可知  x == z   t == y
  - 由此可知x = y = t 
  - 而因为i'外围的x != t 所以i'才扩不动了 产生了矛盾  
  - 因此不能继续外扩 答案就是i'的回文    ====> O(1)
- i关于C对称点i'的回文区域均落在L左边(不压线)  
  - 此时的拓扑结构为(..x[L .. i' ..)t .. C .. y(.. i .. R])z..
  - 因为L..i'包括在i'的回文范围中 因此与i'关于C对称的i必然至少能够回文到R去
  - 由条件知 x == t(x是L左侧紧挨着的点)   t == y(关于C对称)
  - 由传递性 x==y 假定还能外扩 那么y==z  由于传递性应当x==z 
  - 但x!=z 因为关于C对称 如果能扩到z就不应该停在R处
  - 所以此时i回文半径就是i..R   ====> O(1)
- i关于C对称点i'的回文区域压在L上
  - 此时的拓扑结构为x([L .. i' ..)t .. C .. y(.. i .. R])z..
  - 举例: x[abctcba t abctcba] ?    （？不等于x）
  - 此时i'的回文半径就和i到R的距离是一样的  至少是这么长
  - 能否继续往外扩？不知道 要验证 (i走到右边这个t上来的时候 ? == t 就能   ?!=t就不能)
  - 此时i..R一定是回文 可以跳过这几个点的验证 直接从R+1处开始验证即可  ====> O(N)
