# manacher

##  暴力方法  从i位置往左右两边扩   只选字符扩充的话  长度为偶数的字符串是从两字符中间的虚轴扩出去的  可能找不到
--》 引入虚轴 # 标记

## Manacher的改进
- 用pArr数组在从左往右遍历过程中把以i位置为中心的结果记录下来  类似于动规 可以查到之前的结果
- 以i为中心能扩到最远的右边再加1（违规位置）定义为R 
- R更新为更大值的时候 更新当时的回文中心点C 记录下来
- 分类讨论：
  - 当i遍历到R外的时候 没有优化 暴力向外扩充
  - 当i遍历在R内时  必然存在拓扑关系为： [L .. C .. i .. R] 因为i刚到的位置如果在R内 证明R一定是之前更新的 --> C必然在i的左侧而不可能到右侧去 
    - 此时可以找i关于C的对称点i'  [L .. i' .. C .. i .. R]
      - i关于C对称点i'的回文区域均落在L..R范围内  找i'回文区外围紧挨着的x和t 以及i回文区外紧挨着的y和z
        - 此时的拓扑结构为[L .. x(.. i' ..)t .. C .. y(.. i ..)z .. R]
        - 此前遍历到i'时把答案记在了pArr中
        - 因为i与i'关于C对称  i的回文区域应当至少是i'的回文范围
        - 假定还能往外扩 那么y==z   根据关于C对称可知  x == z   t == y
        - 由此可知x = y = t 
        - 而因为i'外围的x != t 所以i'才扩不动了 产生了矛盾  
        - 因此不能继续外扩 答案就是i'的回文    ====> O(1)
      - i关于C对称点i'的回文区域均落在L左边(不压线)  
        - 此时的拓扑结构为(..x[L .. i' ..)t .. C .. y(.. i .. R])z..
        - 因为L..i'包括在i'的回文范围中 因此与i'关于C对称的i必然至少能够回文到R去
        - 由条件知 x == t(x是L左侧紧挨着的点)   t == y(关于C对称)
        - 由传递性 x==y 假定还能外扩 那么y==z  由于传递性应当x==z 
        - 但x!=z 因为关于C对称 如果能扩到z就不应该停在R处
        - 所以此时i回文半径就是i..R   ====> O(1)
      - i关于C对称点i'的回文区域压在L上
        - 此时的拓扑结构为x([L .. i' ..)t .. C .. y(.. i .. R])z..
        - 举例: x[abctcba t abctcba] ?    （？不等于x）
        - 此时i'的回文半径就和i到R的距离是一样的  至少是这么长
        - 能否继续往外扩？不知道 要验证 (i走到右边这个t上来的时候 ? == t 就能   ?!=t就不能)
        - 此时i..R一定是回文 可以跳过这几个点的验证 直接从R+1处开始验证即可  ====> O(N)

## Manacher代码实现
- 分别看看各种情况能够不验证多少个位置
  - i在R外的时候(i>=R, 因为R是第一个违规位置) 至少能够说明i本身一个人的时候回文 有1个位置可以不用验证
  - i在R内的时候 (R>i)
    - i'(也就是2*C-i) 在L..R里的时候  i不用验证的区域就是i'的答案 pArr中记录的那个  
    - i'在L..R外       i..R 不用验证（其实也就是答案）
    - i'压在L上        i..R 不用验（其实也就是答案）
- 所谓判断能够不验证多少个位置 目的在于把几种情况通过一段代码收拢在一起
  - 拿到了四种情况不需要验证的位置之后，进行一个while判断收拢在一块 O(1)去判断一下
    - 后两种情况（i'在L..R外以及i'压在L上）不用验证的区域就是答案本身了  while判断 不进去 省代码
    - while判断的是能否继续向外扩 也就是str[i+pArr[i]] 是否等于 str[i-pArr[i]]