# 滑动窗口
## R往右移动(R++) 新数从右侧进入；L(L++)往右移动 老数从左侧离开  (L <= R)
> 可以用单调双端队列来实现这个结构(Java中LinkedList底层是双端队列实现的)
> + 从头到尾是由大到小的 
> + 更新方式是：
>   1. R向右移动,看试图从尾部新进队列的数是否符合进入后仍维持头到尾大到小的原则  
>   若不符合，从尾部一个一个向外弹出，直到能够把当前数加入
>   (新进来的数既比老数下标更新，值又更大，之前的老人不可能再主政了；相等也扔掉，因为后进来的下标晚过期)
>   2. L向右移动，看头部数的下标是否是要抛弃的下标所对应的数，若是则删除，否则跳过
> + 查询当前滑动窗口最大值即是头部的值
> + 总代价是O(N) -- 每个元素最多进一次出一次  摊还分析 平均处理一个数是O(1)代价

## 题目
 
窗口内最大值或最小值更新结构的实现  
假设一个固定大小为w的窗口，依次划过arr，返回每一次滑出状况的最大值  
例，arr = [4,3,5,4,3,3,6,7], w = 3，返回：[5,5,5,4,6,7]  

给定一个整型数组arr，和一个整数num  
某个arr中的子数组sub，如果想达标，必须满足：sub中最大值 – sub中最小值 <= num，  
返回arr中达标子数组的数量  

加油站的良好出发点问题  

动态规划中利用窗口内最大值或最小值更新结构做优化（难）  
arr是货币数组，其中的值都是正数。再给定一个正数aim。  
每个值都认为是一张货币，  
返回组成aim的最少货币数  
注意：因为是求最少货币数，所以每一张货币认为是相同或者不同就不重要了
