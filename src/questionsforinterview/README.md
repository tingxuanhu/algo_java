# 算法刷题班配套练习

## class1
### CordCoverMaxPoint 绳子覆盖点的问题
思路：
- 小贪心
    - 数组和L长度都是int类型 这意味着绳子没有必要不踩在数组涵盖的整数点上
    - 假定绳子踩在某个点上 那么向左能够覆盖多远 最远下标就是从这个点出发向左扩展L长度
    - 问题也就转化为 数组中究竟有几个点下标小于能够扩展到的最远点
    - 进而可以通过二分最快锁定有序数组中的点
- 复杂度  每次二分lgN级别  N个数扫过去    笔试可以过  O（NlgN）


### CountFiles 数文件
给定一个文件目录的路径，写一个函数统计这个目录下所有的文件数量并返回，隐藏文件也算，但是文件夹不算

### Near2Power
给定一个非负整数num，如何不用循环语句，返回>=num，并且离num最近的，2的某次方
- 思路：
    - 我从最高位的1开始,我不用管后面有几个1,只要它最高的这个1跑完这一系列代码之后,后面全是1
    - 效果就是从最高位的1,开始后面全是1,哪怕你拥有最少数量的1,你最高的只有一个1,跑完之后也会都弄满为1,
    - 如果n正好是2的某次方,比如n=16,兼顾n正好是2的某次方,如果N不是2的某次方这么搞正好够到自己最近的2的某次方。
    - 如果N正好是2的某次方方这么弄,正好够到自己
    - 简单的来说就是num先减1,然后最高为后全弄为1,弄完后再加1;


### MinSwapStep
一个数组中只有两种字符'G'和'B'，
可以让所有的G都放在左侧，所有的B都放在右侧
或者可以让所有的G都放在右侧，所有的B都放在左侧
但是只能在相邻字符之间进行交换操作，请问请问至少需要交换几次，
- 思路：
    - 从左往右第一个G放在0号下标，第二次出现的G放在1号下标，以此类推，G放好了B自然放好，
    - 用两个指针实现


### LongestIncreasingPath
给定一个二维数组matrix，你可以从任何位置出发，走向上、下、左、右四个方向，
返回能走出来的最长的递增链长度


### AOE
给定两个非负数组x和hp，长度都是N，再给定一个正数range
x有序，x[i]表示i号怪兽在x轴上的位置
hp[i]表示i号怪兽的血量
再给定一个正数range，表示如果法师释放技能的范围长度
被打到的每只怪兽损失1点血量。返回要把所有怪兽血量清空，至少需要释放多少次AOE技能？

### TargetSum
给定一个数组arr，你可以在每个数字之前决定+或者-但是必须所有数字都参与，再给定一个数target
请问最后算出target的方法数


## class2
### ChooseWork
给定数组hard和money，长度都为N，hard[i]表示i号工作的难度， money[i]表示i号工作的收入
给定数组ability，长度都为M，ability[j]表示j号人的能力，每一号工作，都可以提供无数的岗位，难度和收入都一样
但是人的能力必须>=这份工作的难度，才能上班。
返回一个长度为M的数组ans，ans[j]表示j号人能获得的最好收入

### Cola  --> 改成ACM模式写法
* 买饮料 时间限制： 3000MS 内存限制： 589824KB 题目描述：
* 游游今年就要毕业了，和同学们在携程上定制了日本毕业旅行。愉快的一天行程结束后大家回到了酒店房间，这时候同学们都很口渴，
* 石头剪刀布选出游游去楼下的自动贩卖机给大家买可乐。 贩卖机只支持硬币支付，且收退都只支持10 ，50，100
* 三种面额。一次购买行为只能出一瓶可乐，且每次购买后总是找零最小枚数的硬币。（例如投入100圆，可乐30圆，则找零50圆一枚，10圆两枚）
* 游游需要购买的可乐数量是 m，其中手头拥有的 10,50,100 面额硬币的枚数分别是 a,b,c，可乐的价格是x(x是10的倍数)。
* 如果游游优先使用大面额购买且钱是够的情况下,请计算出需要投入硬币次数？ 输入描述 依次输入， 需要可乐的数量为 m 10元的张数为 a 50元的张数为 b
* 100元的张树为 c 1瓶可乐的价格为 x 输出描述 输出当前金额下需要投入硬币的次数
* 例如需要购买2瓶可乐，每瓶可乐250圆，手里有100圆3枚，50圆4枚，10圆1枚。 购买第1瓶投递100圆3枚，找50圆 购买第2瓶投递50圆5枚
* 所以是总共需要操作8次金额投递操作 样例输入 2 1 4 3 250 样例输出 8